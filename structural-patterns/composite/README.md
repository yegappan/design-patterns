# Composite Design Pattern in Vim9script

## Overview

The **Composite Pattern** is a structural design pattern that lets you compose objects into tree structures and treat individual objects and compositions uniformly. It is useful for representing part-whole hierarchies.

## Intent

- Compose objects into tree structures
- Treat leaf and composite objects consistently
- Simplify client code by using a common interface
- Model part-whole relationships

## Also Known As

- Part-Whole

## When to Use

Use the Composite pattern when:
- You need to represent hierarchical structures
- Clients should ignore differences between individual and composite objects
- You want to apply operations recursively over a tree
- You want to extend the structure without changing client code

## Structure

```
Client -> Component
           ^   ^
           |   |
         Leaf  Composite -> Component (children)
```

## Participants

1. **Component**: Common interface for leaves and composites (`IComponent`, `IMenuItem`)
2. **Leaf**: Represents end objects (`Label`, `Button`, `MenuItem`)
3. **Composite**: Stores child components (`Panel`, `Menu`)
4. **Client**: Works with the component interface

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, and type aliases:

```vim
interface IComponent
  def Render(indent: number): list<string>
endinterface

class Panel implements IComponent
  var children: list<IComponent>
endclass
```

## Examples Included

### 1. UI Component Tree
**Scenario**: Panels contain widgets (labels and buttons) and render as a tree.

**Components**:
- Component: `IComponent`
- Leaf: `Label`, `Button`
- Composite: `Panel`

**Usage**:
```vim
var root = Panel.new('Root')
root.Add(Label.new('Title', 'Dashboard'))
```

### 2. Menu Composite
**Scenario**: Menus contain menu items and other menus.

**Components**:
- Component: `IMenuItem`
- Leaf: `MenuItem`
- Composite: `Menu`

**Usage**:
```vim
var menu = Menu.new('File')
menu.Add(MenuItem.new('Open', 'Ctrl+O'))
```

## Running the Examples

### Source the file
```vim
:source structural-patterns/composite/composite_pattern.vim
```

### Run the complete demo
```vim
:call g:RunCompositePatternDemo()
```

## Key Concepts Demonstrated

1. **Tree Structure** representation
2. **Uniform Interface** for leaves and composites
3. **Recursive Operations** via `Render()`
4. **Independent Extension** of new leaf or composite types

## Advantages

1. **Uniformity**: Clients treat single and composite objects the same
2. **Extensibility**: Add new components without modifying client code
3. **Simpler Clients**: Fewer conditionals for object type checks
4. **Recursive Power**: Easy to apply operations across the tree

## Disadvantages

1. **Over-Generalization**: Common interface may be too broad
2. **Complexity**: Harder to enforce restrictions on leaf vs composite

## Related Patterns

- **Decorator**: Also uses recursive composition but adds behavior
- **Bridge**: Separates abstraction and implementation
- **Iterator**: Often used to traverse composite structures

## Vim9script Notes

- Interfaces ensure a uniform contract for leaves and composites
- Enums distinguish node kinds for clarity
- Type aliases make intent explicit in signatures

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Composite pattern, visit:

- **Refactoring.Guru**: [Composite Pattern](https://refactoring.guru/design-patterns/composite)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 163-174
- **Wikipedia**: [Composite Pattern](https://en.wikipedia.org/wiki/Composite_pattern)
- **SourceMaking**: [Composite Design Pattern](https://sourcemaking.com/design_patterns/composite)

## Conclusion

The Composite pattern is ideal for hierarchical structures where clients should not care if they are dealing with a single object or a group. This Vim9script example shows how modern language features make the pattern concise and readable.
