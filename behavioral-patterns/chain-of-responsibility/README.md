# Chain of Responsibility Design Pattern in Vim9script

## Overview

The **Chain of Responsibility Pattern** is a behavioral design pattern that passes a request along a chain of handlers. Each handler decides whether to handle the request or pass it to the next handler.

## Intent

- Avoid coupling sender and receiver
- Allow multiple handlers to process a request
- Build flexible chains of responsibility
- Add or reorder handlers without changing client code

## Also Known As

- Chain of Command

## When to Use

Use the Chain of Responsibility pattern when:
- More than one object can handle a request
- You want to decouple request senders from receivers
- The handler chain should be configurable
- You want to apply different logic based on request type

## Structure

```
Client -> Handler -> Handler -> Handler
```

## Participants

1. **Handler**: Defines the handling interface (`IHandler`)
2. **Concrete Handler**: Processes a specific request (`AuthHandler`, `PaymentHandler`)
3. **Client**: Sends requests into the chain (`DemonstrateChain`)

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, type aliases, and an abstract base handler:

```vim
interface IHandler
  def Handle(request: IRequest, output: list<string>): bool
endinterface

abstract class Handler implements IHandler
  var next: IHandler
endclass
```

## Examples Included

### 1. Request Processing Chain
**Scenario**: Authentication, payment, and inventory requests flow through a chain.

**Components**:
- Handlers: `AuthHandler`, `PaymentHandler`, `InventoryHandler`
- Request: `Request` implements `IRequest`

**Usage**:
```vim
var auth = AuthHandler.new()
var payment = PaymentHandler.new(500)
var inventory = InventoryHandler.new()

auth.SetNext(payment).SetNext(inventory)
```

## Running the Examples

### Source the file
```vim
:source behavioral-patterns/chain-of-responsibility/chain_of_responsibility.vim
```

### Run the complete demo
```vim
:call g:RunChainOfResponsibilityDemo()
```

## Key Concepts Demonstrated

1. **Chain Configuration** using `SetNext()`
2. **Handler Responsibility** per request type
3. **Request Passing** when a handler cannot process it
4. **Decoupling** of client from handler implementation

## Advantages

1. **Loose Coupling**: Client unaware of concrete handler
2. **Flexibility**: Add or reorder handlers easily
3. **Single Responsibility**: Each handler focuses on one task

## Disadvantages

1. **Unhandled Requests**: If no handler matches
2. **Debugging Complexity**: Harder to trace the flow

## Related Patterns

- **Command**: Encapsulates requests as objects
- **Decorator**: Uses chained objects with a common interface
- **Observer**: Broadcasts events to multiple listeners

## Vim9script Notes

- Abstract handler base class simplifies passing to next
- Enums describe request kinds cleanly
- Type aliases improve signature clarity

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Chain of Responsibility pattern, visit:

- **Refactoring.Guru**: [Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 223-232
- **Wikipedia**: [Chain of Responsibility Pattern](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern)
- **SourceMaking**: [Chain of Responsibility Design Pattern](https://sourcemaking.com/design_patterns/chain_of_responsibility)

## Conclusion

The Chain of Responsibility pattern enables flexible request processing through a sequence of handlers. This Vim9script example shows how modern language features keep the chain clean and extensible.
