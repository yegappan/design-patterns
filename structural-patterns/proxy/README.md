# Proxy Design Pattern in Vim9script

## Overview

The **Proxy Pattern** is a structural design pattern that provides a surrogate or placeholder for another object to control access to it. Proxies can add behavior such as caching, access control, lazy loading, or logging.

## Intent

- Control access to an object
- Add behavior without changing the real object
- Delay expensive operations until needed
- Provide a stand-in for remote or protected resources

## Also Known As

- Surrogate

## When to Use

Use the Proxy pattern when:
- You need lazy initialization
- You want access control or permissions
- You want caching or logging
- The real object is expensive to create or access

## Structure

```
Client -> Proxy -> Real Subject
            ^
            |
         Subject
```

## Participants

1. **Subject**: Common interface (`IDataStore`, `IImage`)
2. **Real Subject**: Actual implementation (`RealDatabase`, `RealImage`)
3. **Proxy**: Controls access (`DatabaseProxy`, `ProxyImage`)
4. **Client**: Uses the proxy

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, and type aliases:

```vim
interface IDataStore
  def Query(sql: string): list<string>
endinterface

class DatabaseProxy implements IDataStore
  def Query(sql: string): list<string>
endclass
```

## Examples Included

### 1. Database Access Proxy
**Scenario**: Add caching and read-only access control for guests.

**Components**:
- Subject: `IDataStore`
- Real Subject: `RealDatabase`
- Proxy: `DatabaseProxy`

**Usage**:
```vim
var proxy: IDataStore = DatabaseProxy.new(AccessLevel.Guest)
proxy.Query('select * from users')
```

### 2. Image Loading Proxy
**Scenario**: Lazy-load images when first displayed.

**Components**:
- Subject: `IImage`
- Real Subject: `RealImage`
- Proxy: `ProxyImage`

**Usage**:
```vim
var image: IImage = ProxyImage.new('assets/hero.png')
image.Display()
```

## Running the Examples

### Source the file
```vim
:source structural-patterns/proxy/proxy_pattern.vim
```

### Run the complete demo
```vim
:call g:RunProxyPatternDemo()
```

## Key Concepts Demonstrated

1. **Access Control** with a proxy wrapper
2. **Lazy Initialization** for expensive objects
3. **Caching** to reuse results
4. **Uniform Interface** for proxy and real subject

## Advantages

1. **Control**: Add checks and safeguards
2. **Performance**: Cache or delay expensive work
3. **Transparency**: Client uses the same interface
4. **Flexibility**: Swap proxy or real subject at runtime

## Disadvantages

1. **Indirection**: Extra layer can complicate debugging
2. **Latency**: Proxy logic may add overhead

## Related Patterns

- **Decorator**: Adds behavior but with the same interface
- **Facade**: Simplifies access to a subsystem
- **Adapter**: Changes interface

## Vim9script Notes

- Interfaces keep proxy and real subject consistent
- Enums express access state clearly
- Type aliases clarify return types

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Proxy pattern, visit:

- **Refactoring.Guru**: [Proxy Pattern](https://refactoring.guru/design-patterns/proxy)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 207-217
- **Wikipedia**: [Proxy Pattern](https://en.wikipedia.org/wiki/Proxy_pattern)
- **SourceMaking**: [Proxy Design Pattern](https://sourcemaking.com/design_patterns/proxy)

## Conclusion

The Proxy pattern gives you a controlled stand-in for real objects, enabling lazy loading, access control, and caching without changing the client interface. This Vim9script example demonstrates both a protection proxy and a virtual proxy.
