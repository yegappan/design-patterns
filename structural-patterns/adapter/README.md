# Adapter Design Pattern in Vim9script

## Overview

The **Adapter Pattern** is a structural design pattern that allows objects with incompatible interfaces to collaborate by translating one interface into another.

## Intent

- Convert an interface into one that clients expect
- Reuse existing classes with incompatible APIs
- Isolate translation logic in adapters

## Also Known As

- Wrapper

## When to Use

Use the Adapter pattern when:
- You need to integrate a class with an incompatible interface
- You are wrapping a third-party or legacy API
- You want to keep client code stable while adapting dependencies

## Structure

```
Client -> Target
Adapter -> Adaptee
```

## Participants

1. **Target**: The interface clients expect
2. **Adapter**: Translates calls to the adaptee
3. **Adaptee**: The existing incompatible class
4. **Client**: Uses the target interface

## Implementation in Vim9script

Vim9script uses object adapters via composition:

```vim
abstract class MediaPlayer
  abstract def Play(filename: string): list<string>
endclass

class MediaAdapter extends MediaPlayer
  var advancedPlayer: AdvancedAudioPlayer
endclass
```

## Examples Included

### 1. Media Player Adapter
**Scenario**: A basic player supports additional formats via adapters.

**Components**:
- Target: `MediaPlayer`
- Adaptee: `AdvancedAudioPlayer`
- Adapter: `MediaAdapter`

**Usage**:
```vim
var player = AudioPlayer.new()
player.Play('movie.mp4')
```

### 2. Payment Gateway Adapter
**Scenario**: Multiple payment APIs share a common interface.

### 3. Data Format Adapter
**Scenario**: XML sources are exposed through a JSON API.

### 4. Legacy System Adapter
**Scenario**: Fahrenheit sensors are adapted to Celsius.

## Running the Examples

### Source the file
```vim
:source structural-patterns/adapter/adapter_pattern.vim
```

### Run the complete demo
```vim
:call g:RunAdapterPatternDemo()
```

## Key Concepts Demonstrated

1. **Interface Translation** through adapters
2. **Composition Over Inheritance** for flexibility
3. **Transparent Integration** for clients

## Advantages

1. **Reusability**: Keep existing classes intact
2. **Open/Closed Principle**: Add adapters without changing clients
3. **Separation of Concerns**: Translation logic is isolated

## Disadvantages

1. **Extra Indirection**: Adds a translation layer
2. **Complexity**: More classes to manage

## Related Patterns

- **Bridge**: Separates abstraction and implementation
- **Decorator**: Adds behavior without changing interface
- **Proxy**: Controls access to an object

## Vim9script Notes

- Prefer object adapters since Vim9script lacks multiple inheritance
- Abstract classes define target interfaces clearly
- Type annotations keep method signatures explicit

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Adapter pattern, visit:

- **Refactoring.Guru**: [Adapter Pattern](https://refactoring.guru/design-patterns/adapter)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 139-150
- **Wikipedia**: [Adapter Pattern](https://en.wikipedia.org/wiki/Adapter_pattern)
- **SourceMaking**: [Adapter Design Pattern](https://sourcemaking.com/design_patterns/adapter)

## Conclusion

The Adapter pattern enables clean integration of incompatible interfaces. This Vim9script example shows how composition-based adapters keep client code stable while reusing existing implementations.
