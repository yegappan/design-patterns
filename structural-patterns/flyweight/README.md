# Flyweight Design Pattern in Vim9script

## Overview

The **Flyweight Pattern** is a structural design pattern that reduces memory usage by sharing common (intrinsic) state between many objects. It is useful when large numbers of similar objects are created.

## Intent

- Share common state to reduce memory usage
- Separate intrinsic and extrinsic state
- Optimize performance for large object counts
- Provide a factory for flyweight reuse

## Also Known As

- Cache

## When to Use

Use the Flyweight pattern when:
- You need many similar objects
- Memory usage is a concern
- Objects can share immutable state
- Extrinsic state can be supplied externally

## Structure

```
Client -> Flyweight Factory -> Flyweight
                ^
                |
         Intrinsic State Cache
```

## Participants

1. **Flyweight**: Shared object (`CircleShape`, `SquareShape`)
2. **Flyweight Factory**: Manages reuse (`ShapeFactory`)
3. **Context**: Stores extrinsic state (`ForestRenderer` items)
4. **Client**: Uses factory and contexts

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, and type aliases:

```vim
interface IShape
  def Draw(x: number, y: number, size: number): string
endinterface

class ShapeFactory
  def GetShape(kind: ShapeKind, color: string, texture: string): IShape
endclass
```

## Examples Included

### 1. Forest Renderer
**Scenario**: Many trees share shapes, colors, and textures.

**Components**:
- Flyweights: `CircleShape`, `SquareShape`
- Factory: `ShapeFactory`
- Context: `ForestRenderer`

**Usage**:
```vim
var factory = ShapeFactory.new()
var forest = ForestRenderer.new(factory)
forest.AddTree(ShapeKind.Circle, 'green', 'leafy', 10, 12, 5)
```

## Running the Examples

### Source the file
```vim
:source structural-patterns/flyweight/flyweight_pattern.vim
```

### Run the complete demo
```vim
:call g:RunFlyweightPatternDemo()
```

## Key Concepts Demonstrated

1. **Intrinsic vs Extrinsic State** separation
2. **Object Sharing** through a factory cache
3. **Memory Efficiency** with many similar objects

## Advantages

1. **Reduced Memory Usage**: Share common state
2. **Improved Performance**: Fewer object allocations
3. **Centralized Creation**: Factory manages reuse

## Disadvantages

1. **Complexity**: Requires separating state
2. **Potential Coupling**: Clients must supply extrinsic state

## Related Patterns

- **Factory Method**: Often used to create flyweights
- **Composite**: Works well with flyweights in trees
- **Facade**: Can hide flyweight complexity

## Vim9script Notes

- Interfaces represent flyweight contracts
- Enums define shape types
- Type aliases make signature intent clear

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Flyweight pattern, visit:

- **Refactoring.Guru**: [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 195-207
- **Wikipedia**: [Flyweight Pattern](https://en.wikipedia.org/wiki/Flyweight_pattern)
- **SourceMaking**: [Flyweight Design Pattern](https://sourcemaking.com/design_patterns/flyweight)

## Conclusion

The Flyweight pattern helps reduce memory usage when many objects share common state. This Vim9script example shows how a factory can reuse shapes while each tree supplies its own position and size.
