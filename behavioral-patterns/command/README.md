# Command Design Pattern in Vim9script

## Overview

The **Command Pattern** is a behavioral design pattern that encapsulates a request as an object. This allows you to parameterize clients with different requests, queue commands, and support undo/redo.

## Intent

- Encapsulate requests as objects
- Decouple sender and receiver
- Support command queues and logs
- Enable undo/redo and transactional behavior

## Also Known As

- Action

## When to Use

Use the Command pattern when:
- You need to queue or schedule operations
- You want to parameterize behavior
- You need undo/redo support
- You want to log or replay actions

## Structure

```
Client -> Invoker -> Command -> Receiver
```

## Participants

1. **Command**: Interface for all commands (`ICommand`)
2. **Concrete Command**: Implements action (`DepositCommand`, `WithdrawCommand`)
3. **Receiver**: Performs the work (`BankAccount`)
4. **Invoker**: Triggers commands (`CommandInvoker`)
5. **Client**: Creates and configures commands

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, type aliases, and an abstract base class:

```vim
interface ICommand
  def Execute(output: list<string>): void
endinterface

abstract class CommandBase
  abstract def Execute(output: list<string>): void
endclass
```

## Examples Included

### 1. Banking Commands
**Scenario**: Deposit, withdraw, and transfer commands are queued and executed.

**Components**:
- Receiver: `BankAccount`
- Commands: `DepositCommand`, `WithdrawCommand`, `TransferCommand`
- Invoker: `CommandInvoker`

**Usage**:
```vim
var invoker = CommandInvoker.new()
invoker.Add(DepositCommand.new(checking, 200))
invoker.Run([])
```

## Running the Examples

### Source the file
```vim
:source behavioral-patterns/command/command_pattern.vim
```

### Run the complete demo
```vim
:call g:RunCommandPatternDemo()
```

## Key Concepts Demonstrated

1. **Request Encapsulation** as objects
2. **Command Queueing** via `CommandInvoker`
3. **Decoupling** of sender and receiver
4. **Composable Workflows** using command lists

## Advantages

1. **Flexibility**: Add commands without changing invoker
2. **Queueing**: Schedule or batch execution
3. **Auditability**: Log or replay command history
4. **Undo/Redo**: Possible with extra command state

## Disadvantages

1. **More Classes**: Each command is a new type
2. **Indirection**: Adds an extra layer to trace

## Related Patterns

- **Chain of Responsibility**: Passes requests along handlers
- **Memento**: Often used for undo/redo
- **Strategy**: Similar encapsulation but without invoker/receiver

## Vim9script Notes

- Interfaces keep command types consistent
- Abstract base class demonstrates a common command contract
- Enums and type aliases clarify intent in signatures

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Command pattern, visit:

- **Refactoring.Guru**: [Command Pattern](https://refactoring.guru/design-patterns/command)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 233-242
- **Wikipedia**: [Command Pattern](https://en.wikipedia.org/wiki/Command_pattern)
- **SourceMaking**: [Command Design Pattern](https://sourcemaking.com/design_patterns/command)

## Conclusion

The Command pattern provides a clean way to encapsulate actions as objects. This Vim9script example shows how to queue operations and execute them in a predictable order using modern language features.
