# Bridge Design Pattern in Vim9script

## Overview

The **Bridge Pattern** is a structural design pattern that decouples an abstraction from its implementation so the two can vary independently. It is especially useful when both the abstraction and the implementation may change over time.

## Intent

- Decouple an abstraction from its implementation
- Allow both abstraction and implementation to evolve independently
- Favor composition over inheritance
- Avoid a permanent binding between abstraction and implementation

## Also Known As

- Handle/Body

## When to Use

Use the Bridge pattern when:
- You want to avoid a class explosion from combining multiple dimensions
- You need to swap implementations at runtime
- You want to separate high-level behavior from low-level details
- You need to extend abstractions and implementations independently

## Structure

```
Client -> Abstraction -> Implementor
              ^              ^
          Refined        Concrete
        Abstraction     Implementor
```

## Participants

1. **Abstraction**: High-level control logic (e.g., `RemoteControl`)
2. **Refined Abstraction**: Specialized abstraction (e.g., `SmartRemote`)
3. **Implementor**: Interface for implementation classes (e.g., `IDevice`)
4. **Concrete Implementor**: Specific implementations (e.g., `Radio`, `Tv`)

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, and type aliases:

```vim
interface IDevice
    def GetName(): string
    def GetVolume(): number
    def SetVolume(level: number)
    def TogglePower(): string
endinterface

class RemoteControl
    var device: IDevice
    def new(device: IDevice, step: number)
        this.device = device
    enddef
endclass
```

## Examples Included

### 1. Remote and Device Bridge
**Scenario**: Remotes (abstraction) control devices (implementation) without coupling.

**Components**:
- Abstraction: `RemoteControl`
- Refined Abstraction: `SmartRemote`
- Implementor: `IDevice`
- Concrete Implementors: `Radio`, `Tv`

**Usage**:
```vim
var radio = Radio.new('Radio', 10)
var remote = RemoteControl.new(radio, 5)
remote.TogglePower()
```

### 2. Report and Formatter Bridge
**Scenario**: Reports (abstraction) render output via formatters (implementation).

**Components**:
- Abstraction: `Report`
- Refined Abstraction: `SalesReport`
- Implementor: `IFormatter`
- Concrete Implementors: `PlainTextFormatter`, `MarkdownFormatter`

**Usage**:
```vim
var report = SalesReport.new(MarkdownFormatter.new())
var lines = report.RenderSummary()
```

## Running the Examples

### Source the file
```vim
:source structural-patterns/bridge/bridge_pattern.vim
```

### Run the complete demo
```vim
:call g:RunBridgePatternDemo()
```

## Key Concepts Demonstrated

1. **Abstraction and Implementation Separation**
2. **Independent Variation** of remotes vs devices, reports vs formatters
3. **Composition Over Inheritance** via `IDevice` and `IFormatter`
4. **Runtime Swapping** of concrete implementors

## Advantages

1. **Flexibility**: Swap implementations without changing abstractions
2. **Scalability**: Prevent combinatorial class growth
3. **Maintainability**: Clear separation of concerns
4. **Extensibility**: Add new abstractions or implementations easily

## Disadvantages

1. **Complexity**: More classes and indirection
2. **Overhead**: Extra abstraction may be unnecessary for small problems

## Related Patterns

- **Adapter**: Changes interface, Bridge separates abstraction and implementation
- **Decorator**: Adds responsibilities without changing interface
- **Strategy**: Encapsulates algorithms, similar to swapping implementations

## Vim9script Notes

- Interfaces and classes make the pattern explicit
- Enums illustrate state and styling options
- Type aliases make intent clear in signatures

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Bridge pattern, visit:

- **Refactoring.Guru**: [Bridge Pattern](https://refactoring.guru/design-patterns/bridge)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 151-162
- **Wikipedia**: [Bridge Pattern](https://en.wikipedia.org/wiki/Bridge_pattern)
- **SourceMaking**: [Bridge Design Pattern](https://sourcemaking.com/design_patterns/bridge)

## Conclusion

The Bridge pattern keeps abstractions and implementations independent, making it a great fit for systems that evolve along multiple dimensions. This Vim9script example highlights how modern language features make the separation clean and expressive.
