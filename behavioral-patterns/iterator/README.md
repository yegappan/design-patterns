# Iterator Design Pattern in Vim9script

## Overview

The **Iterator Pattern** is a behavioral design pattern that provides a way to access elements of a collection sequentially without exposing its underlying representation.

## Intent

- Provide a uniform way to traverse collections
- Hide internal collection structure
- Support multiple traversal strategies
- Simplify client code

## Also Known As

- Cursor

## When to Use

Use the Iterator pattern when:
- Collections need multiple traversal strategies
- You want to decouple traversal logic from collections
- Clients should not depend on internal data structures

## Structure

```
Client -> Iterator
Client -> Aggregate -> Iterator
```

## Participants

1. **Iterator**: Traversal interface (`IIterator`)
2. **Concrete Iterator**: Implements traversal (`ForwardIterator`, `ReverseIterator`)
3. **Aggregate**: Collection interface (`IAggregate`)
4. **Concrete Aggregate**: Stores items (`StringCollection`)

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, type aliases, and abstract classes:

```vim
interface IIterator
  def HasNext(): bool
  def Next(): string
endinterface

class ForwardIterator implements IIterator
  def Next(): string
endclass
```

## Examples Included

### 1. String Collection Iteration
**Scenario**: Traverse a collection forward and backward using iterators.

**Components**:
- Aggregate: `StringCollection`
- Iterators: `ForwardIterator`, `ReverseIterator`

**Usage**:
```vim
var collection = StringCollection.new(['a', 'b', 'c'])
var it = collection.CreateIterator(TraversalOrder.Forward)
```

## Running the Examples

### Source the file
```vim
:source behavioral-patterns/iterator/iterator_pattern.vim
```

### Run the complete demo
```vim
:call g:RunIteratorPatternDemo()
```

## Key Concepts Demonstrated

1. **Encapsulated Traversal** via iterator objects
2. **Multiple Traversal Orders** using `TraversalOrder`
3. **Separation of Concerns** between collection and iteration

## Advantages

1. **Flexibility**: Add new traversal strategies easily
2. **Consistency**: Uniform iteration interface
3. **Encapsulation**: Collection internals stay hidden

## Disadvantages

1. **Overhead**: Additional iterator objects
2. **Complexity**: More classes compared to direct access

## Related Patterns

- **Composite**: Often traversed with iterators
- **Visitor**: Can use iterators to apply operations
- **Command**: Another behavioral encapsulation pattern

## Vim9script Notes

- Interfaces define iterator contracts
- Enums allow multiple traversal modes
- Type aliases clarify intent in signatures

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Iterator pattern, visit:

- **Refactoring.Guru**: [Iterator Pattern](https://refactoring.guru/design-patterns/iterator)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 257-271
- **Wikipedia**: [Iterator Pattern](https://en.wikipedia.org/wiki/Iterator_pattern)
- **SourceMaking**: [Iterator Design Pattern](https://sourcemaking.com/design_patterns/iterator)

## Conclusion

The Iterator pattern provides a clean way to traverse collections while hiding internal structure. This Vim9script example demonstrates forward and reverse traversal with modern language features.
