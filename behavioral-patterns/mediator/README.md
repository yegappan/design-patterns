# Mediator Design Pattern in Vim9script

## Overview

The **Mediator Pattern** is a behavioral design pattern that defines an object that encapsulates how a set of objects interact. It promotes loose coupling by preventing objects from referring to each other explicitly.

## Intent

- Centralize communication between objects
- Reduce dependencies between participants
- Simplify complex interactions
- Make communication protocols reusable

## Also Known As

- Controller

## When to Use

Use the Mediator pattern when:
- Many objects communicate in complex ways
- You want to reduce many-to-many dependencies
- You want to reuse communication rules
- You want to keep participants simpler

## Structure

```
Participants <-> Mediator
```

## Participants

1. **Mediator**: Defines communication interface (`IMediator`)
2. **Concrete Mediator**: Implements coordination (`ChatRoom`)
3. **Colleague/Participant**: Uses mediator (`ChatUser`)

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, type aliases, and abstract classes:

```vim
interface IMediator
  def Notify(sender: string, event: EventType, payload: string, output: list<string>): void
endinterface

class ChatRoom implements IMediator
endclass
```

## Examples Included

### 1. Chat Room Mediator
**Scenario**: Users send messages through a chat room mediator.

**Components**:
- Mediator: `ChatRoom`
- Participants: `ChatUser`

**Usage**:
```vim
var room = ChatRoom.new()
room.Register(ChatUser.new('Alice', room), [])
```

## Running the Examples

### Source the file
```vim
:source behavioral-patterns/mediator/mediator_pattern.vim
```

### Run the complete demo
```vim
:call g:RunMediatorPatternDemo()
```

## Key Concepts Demonstrated

1. **Centralized Communication** via mediator
2. **Loose Coupling** between participants
3. **Event Routing** using `EventType`

## Advantages

1. **Reduced Dependencies** between participants
2. **Simpler Colleagues** that only talk to mediator
3. **Reusable Communication Logic**

## Disadvantages

1. **God Object Risk** if mediator grows too large
2. **Indirect Communication** can be harder to trace

## Related Patterns

- **Observer**: One-to-many notifications
- **Command**: Encapsulates requests
- **Facade**: Simplifies subsystem access

## Vim9script Notes

- Interfaces define mediator and participant contracts
- Enums specify event types
- Type aliases improve signature clarity

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Mediator pattern, visit:

- **Refactoring.Guru**: [Mediator Pattern](https://refactoring.guru/design-patterns/mediator)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 273-282
- **Wikipedia**: [Mediator Pattern](https://en.wikipedia.org/wiki/Mediator_pattern)
- **SourceMaking**: [Mediator Design Pattern](https://sourcemaking.com/design_patterns/mediator)

## Conclusion

The Mediator pattern centralizes communication between objects, reducing coupling. This Vim9script example demonstrates how a chat room mediates messages between users using modern language features.
