# Abstract Factory Design Pattern in Vim9script

## Overview

The **Abstract Factory Pattern** is a creational design pattern that provides an interface for creating families of related objects without specifying their concrete classes.

## Intent

- Create families of related products together
- Hide concrete product classes from clients
- Keep product families consistent
- Swap entire families by changing the factory

## Also Known As

- None

## When to Use

Use the Abstract Factory pattern when:
- You need to create related objects that must work together
- You want to isolate client code from concrete classes
- You may need to switch product families at runtime

## Structure

```
Client -> AbstractFactory -> AbstractProduct
Client -> ConcreteFactory -> ConcreteProduct
```

## Participants

1. **Abstract Factory**: Declares creation methods (`GUIFactory`)
2. **Concrete Factories**: Create platform families (`WindowsFactory`, `LinuxFactory`, `MacOSFactory`)
3. **Abstract Products**: Product interfaces (`Button`, `Checkbox`, `TextInput`)
4. **Concrete Products**: Platform-specific components
5. **Client**: Uses only abstract interfaces (`LoginDialog`)

## Implementation in Vim9script

The example uses Vim9 classes, abstract classes, and type annotations:

```vim
abstract class GUIFactory
  abstract def CreateButton(): Button
  abstract def CreateCheckbox(): Checkbox
endclass
```

## Examples Included

### 1. Platform-Specific UI Components
**Scenario**: A login dialog renders buttons, checkboxes, and inputs per platform.

**Components**:
- Factories: `WindowsFactory`, `LinuxFactory`, `MacOSFactory`
- Products: `Button`, `Checkbox`, `TextInput` and their concrete variants
- Client: `LoginDialog`

**Usage**:
```vim
var factory = WindowsFactory.new()
var dialog = LoginDialog.new(factory)
dialog.Render()
```

## Running the Examples

### Source the file
```vim
:source abstract_factory.vim
```

### Run the complete demo
```vim
:call g:RunAbstractFactoryDemo()
```

## Key Concepts Demonstrated

1. **Family Consistency** using one factory per platform
2. **Encapsulation** of concrete product classes
3. **Factory Swapping** to change UI families

## Advantages

1. **Consistency**: Products in the same family match
2. **Isolation**: Client depends on abstractions only
3. **Extensibility**: Add families without changing clients

## Disadvantages

1. **More Classes**: Multiple product types per family
2. **Factory Changes**: New product types require factory updates

## Related Patterns

- **Factory Method**: Creates a single product type
- **Builder**: Constructs complex objects step by step
- **Prototype**: Clones preconfigured products

## Vim9script Notes

- Abstract classes define factory and product contracts
- Type annotations make interfaces explicit
- Global demo function exposes a simple entry point

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Abstract Factory pattern, visit:

- **Refactoring.Guru**: [Abstract Factory Pattern](https://refactoring.guru/design-patterns/abstract-factory)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 87-96
- **Wikipedia**: [Abstract Factory Pattern](https://en.wikipedia.org/wiki/Abstract_factory_pattern)
- **SourceMaking**: [Abstract Factory Design Pattern](https://sourcemaking.com/design_patterns/abstract_factory)

## Conclusion

The Abstract Factory pattern keeps related products consistent while isolating client code from concrete types. This Vim9script example demonstrates platform-specific UI families with clear factory boundaries.
