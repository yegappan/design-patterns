# Strategy Design Pattern in Vim9script

## Overview

The **Strategy Pattern** is a behavioral design pattern that defines a family of algorithms and makes them interchangeable. The strategy can be selected at runtime without changing the context.

## Intent

- Encapsulate algorithms behind a common interface
- Swap algorithms dynamically
- Simplify context logic

## Also Known As

- Policy

## When to Use

Use the Strategy pattern when:
- You have multiple ways to perform an operation
- You want to avoid large conditionals for algorithm choice
- You want to swap behavior at runtime

## Structure

```
Context -> Strategy
Strategy -> ConcreteStrategy
```

## Participants

1. **Strategy**: Algorithm interface (`IDiscountStrategy`)
2. **Concrete Strategy**: Implementations (`SeasonalDiscount`, `LoyaltyDiscount`)
3. **Context**: Uses a strategy (`PricingContext`)

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, type aliases, and abstract classes:

```vim
interface IDiscountStrategy
  def Apply(amount: float): float
endinterface

class PricingContext
  var strategy: IDiscountStrategy
endclass
```

## Examples Included

### 1. Pricing Strategies
**Scenario**: Pricing changes based on discount strategy.

**Components**:
- Strategies: `NoDiscount`, `SeasonalDiscount`, `LoyaltyDiscount`
- Context: `PricingContext`

**Usage**:
```vim
var context = PricingContext.new(NoDiscount.new())
context.SetStrategy(SeasonalDiscount.new(15))
```

## Running the Examples

### Source the file
```vim
:source behavioral-patterns/strategy/strategy_pattern.vim
```

### Run the complete demo
```vim
:call g:RunStrategyPatternDemo()
```

## Key Concepts Demonstrated

1. **Strategy Encapsulation** behind a common interface
2. **Runtime Switching** via `SetStrategy`
3. **Clean Context** without algorithm conditionals

## Advantages

1. **Open/Closed Principle**: Add strategies without modifying context
2. **Interchangeability**: Swap strategies at runtime
3. **Single Responsibility**: Each strategy encapsulates one algorithm

## Disadvantages

1. **More Classes**: Each strategy is a separate class
2. **Configuration**: Client must choose strategies

## Related Patterns

- **State**: Similar structure but different intent
- **Command**: Encapsulates actions
- **Template Method**: Algorithm skeleton in base class

## Vim9script Notes

- Interfaces keep strategies interchangeable
- Enums provide strategy labels in examples
- Type aliases clarify financial values

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the Strategy pattern, visit:

- **Refactoring.Guru**: [Strategy Pattern](https://refactoring.guru/design-patterns/strategy)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 315-323
- **Wikipedia**: [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
- **SourceMaking**: [Strategy Design Pattern](https://sourcemaking.com/design_patterns/strategy)

## Conclusion

The Strategy pattern lets you select and swap algorithms at runtime without changing context code. This Vim9script example demonstrates pricing strategies using modern language features.
