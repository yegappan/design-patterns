# State Design Pattern in Vim9script

## Overview

The **State Pattern** is a behavioral design pattern that allows an object to change its behavior when its internal state changes. The object appears to change its class.

## Intent

- Encapsulate state-specific behavior
- Allow behavior changes without conditionals
- Make state transitions explicit

## Also Known As

- Objects for States

## When to Use

Use the State pattern when:
- Behavior depends on internal state
- You have large conditionals for state transitions
- You want to add new states without changing existing logic

## Structure

```
Context -> State
State -> ConcreteState
```

## Participants

1. **Context**: Holds the current state (`DoorContext`)
2. **State**: Interface for behavior (`IState`)
3. **Concrete States**: Implement behavior (`LockedState`, `UnlockedState`, `OpenState`)

## Implementation in Vim9script

The example uses Vim9 classes, interfaces, enums, type aliases, and abstract classes:

```vim
interface IState
  def OnOpen(ctx: dict<any>, output: list<string>): void
endinterface

class DoorContext
  var state: IState
endclass
```

## Examples Included

### 1. Door State Machine
**Scenario**: A door transitions between locked, unlocked, and open states.

**Components**:
- Context: `DoorContext`
- States: `LockedState`, `UnlockedState`, `OpenState`

**Usage**:
```vim
var door = DoorContext.new()
door.Unlock([])
```

## Running the Examples

### Source the file
```vim
:source behavioral-patterns/state/state_pattern.vim
```

### Run the complete demo
```vim
:call g:RunStatePatternDemo()
```

## Key Concepts Demonstrated

1. **State Encapsulation** in separate classes
2. **Explicit Transitions** by changing `state`
3. **Behavior Changes** based on current state

## Advantages

1. **Cleaner Logic**: Replaces complex conditionals
2. **Extensible**: Add states without modifying context
3. **Open/Closed Principle**: States are isolated

## Disadvantages

1. **More Classes**: Each state is a separate class
2. **State Explosion**: Many states can become complex

## Related Patterns

- **Strategy**: Similar structure but different intent
- **State Machine**: Formalized state transitions
- **Memento**: Can store state history

## Vim9script Notes

- Enums represent state names for reporting
- Abstract base states define required handlers
- Type aliases keep signatures concise

## Requirements

- Vim 9.0 or later (for Vim9script class support)
- No external dependencies

## License

MIT License - Feel free to use this for learning and teaching design patterns!

## Credits

These design pattern examples were generated by GitHub Copilot to demonstrate modern Vim9script capabilities and software design principles.

## References

For more information about the State pattern, visit:

- **Refactoring.Guru**: [State Pattern](https://refactoring.guru/design-patterns/state)
- **Gang of Four Book**: "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides - Pages 305-313
- **Wikipedia**: [State Pattern](https://en.wikipedia.org/wiki/State_pattern)
- **SourceMaking**: [State Design Pattern](https://sourcemaking.com/design_patterns/state)

## Conclusion

The State pattern lets objects change behavior by switching state objects. This Vim9script example demonstrates a door controller with clear state transitions using modern language features.
